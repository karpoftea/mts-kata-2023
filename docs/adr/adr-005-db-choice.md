- [Title](#title)
- [Status](#status)
- [Context](#context)
  - [Оценка нагрузки на БД](#оценка-нагрузки-на-бд)
  - [Оценка кол-ва данных в БД](#оценка-кол-ва-данных-в-бд)
- [Decision](#decision)
- [Alternatives](#alternatives)
  - [Использование MongoDB](#использование-mongodb)

# Title
Выбор технологии СУБД

# Status
Proposed

# Context
На данном этапе мы определились, что система будет основана на наборе взаимодействующих сервисов (service-based architecture style) каждый из которых будет иметь свою (логическую) БД. Мы также знаем, что файлы: медиа-контент, домашние задания и пр мы будем хранить в объектном хранилище (s3-compatible storage). Мы знаем что сейчас в системе около 3000 пользователей в год и планируемся расширение до 10000 активных пользователей. Заказчик целится в 10 млн. просмотров уроков в год. 

## Оценка нагрузки на БД
Мы предполагаем, что 
1. дети скорее склонны проходить курсы в течение учебного года, чем в каникулы/выходные, поэтому принимаем за допущение, что год = 168 учебных дней + 22 выходных дней (~ 10% от всех выходных дней) = 190 дней.
2. мы предполагаем, что запросы будут выполняться в часы отдельные от школьных занятий, то есть с 13-00 до 22-00. 
3. поскольку география пользователей вся Россия, то мы примаем за допущение, что в часы нагрузки запросы разделены равномерно (пренебрегаем асимметричностью распределения населения) 
4. просмотры не распределены равномерно по дням, а варьируются на основании маркетинговых кампаний. Мы принимаем за допущение, что в ЧНН кол-во просмотров уроков возрастает в 3 раза по сравнению с обычным.
5. самым нагруженным будет сервис курсов (CourceManager), поскольку он хранит структуру курсов/уроков. Мы принимаем за допущение, что для отображения интерфейсов курсов единомоментно потребуется не более 1 запроса (например, листинг курсов/уроков, загрузка конкретного курса/урока)

Таким образом можем оценить кол-во запросов в БД:
```plain
кол-во_запросов_в_сек_в_чнн = коэф_в_чнн * сред_кол-во_запросов_в_сек

сред_кол-во_запросов_в_сек = всего_запросов / (кол-во_дней * кол-во_часов_в_дне * кол-во_минут_в_часе * кол-во_сек_в_часе)
```

Рассчет:
```plain
сред_кол-во_запросов_в_сек = 10000000/(190*9*60*60) = 1.62 rps
кол-во_запросов_в_сек_в_чнн = 3 * 1.62 ~ 5 rps
```

Мы примем за горизонт планирования 3 года, предполагая что каждый год нагрузка растет на 100%. Таким образом оценочная нагрузка на БД:
- 2023г: 5 rps
- 2024г: 10 rps
- 2025г: 20 rps

## Оценка кол-ва данных в БД
Мы предполагаем, что 
1. к концу 2024 года кол-во курсов будет 20 (планы заказчика)
2. мы принимаем за допущение, что в каждом курсе будет в среднем 15 уроков
3. мы принимаем за допущение, что кроме курсов других активностей будет 50 штук (1 активность в неделю)
4. мы принимаем за допущение, что кол-во метаданных для урока/активности составляет ~ 100 КB

Таким образом можем оценить кол-во данных в БД:
```plain
кол-во_данных_MB = (кол_во_эл_обучения * кол-во_метаданных_для_эл_обучения_KB) / 1024

кол_во_эл_обучения = кол-во_курсов * кол-во_уроков_в_курсе + кол-во_активностей
```

Рассчет:
```plain
кол_во_эл_обучения = 20 * 15 + 50 = 350

кол-во_данных_MB = (350 * 100) / 1024 ~ 35 MB
```

Мы примем за горизонт планирования 3 года, предполагая что каждый год кол-во данных растет на 100%. Таким образом оценочная кол-во в БД:
- 2023г: 35 MB
- 2024г: 70 MB
- 2025г: 140 MB

# Decision
Мы будем использовать реляционную БД для хранения метаданных для обучения (структуры курсов, уровков, оценки, записи на уроки и тп). В качестве реализации РСУБД мы будем использовать PostgreSQL.

Мы будем разворачивать PostgreSQL в управляемом сервиса PostgreSQL в Ocean, в кластерном режиме. Это позволит нам добиваться нужного уровня доступности. 

Мы будем использовать асинхронную репликацию между мастером и репликами. Это оправдано поскольку, позволяет добиться более высокого уровня доступности в ущерб согласованности. Мы можем пойти на некоторый уровень несогласованности поскольку:
1. данные курсов обновляются редко
2. операции которые производят клиенты можно перепровести (снова записаться на курс, сдать домашнюю работу и тп)

Производительность PostgreSQL удовлетворяет оценкам выше.

В случае непредвиденного увеличения нагрузки, мы будем использовать локальное кеширование данных на серверах, а также кеширование REST-запросов. Мы можем это сделать для любых элементов обучения, поскольку они сравнительно редко обновляются.

# Alternatives
Мы рассматривали следующие альтернативы: использование MongoDB

## Использование MongoDB
Мы отказались от использования MongoDB из-за низких требований к нагрузке и кол-ву данных которые необходимы системе. Кроме того инсталляция MongoDB в отказоустойчивом режиме требует минимум 3 хостов, что дороже. Отдельным, хоть и менее значимым фактором является, то что разработчики более знакомы с реляционными БД, а инструментарий работы с ними более богатый.